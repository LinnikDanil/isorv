# 1. Техническое задание

Для создания фронтенд-части приложения для опросов на основе указанных технологий, техническое задание может включать
следующие компоненты и рекомендации:

### 1. Настройка проекта:

- **Создание проекта**: Используйте Vite с шаблоном React для инициализации проекта.
- **Установка зависимостей**: Используйте Yarn для установки всех необходимых
  зависимостей (`react`, `redux`, `react-router-dom`, `socket.io-client`, `axios`, `jest`, и др.).
- **Структура каталогов**: Организуйте файлы проекта в каталоги по функциональности (
  например, `components`, `containers`, `store`, `services`, `utils`, `styles`, `tests`).

### 2. Стилизация:

- **CSS**: Используйте CSS модули или styled-components для стилизации компонентов. Создайте глобальные CSS переменные
  для цветов, шрифтов и других повторяющихся стилей.

### 3. Роутинг:

- **React Router**: Настройте маршрутизацию для следующих маршрутов:
    - `/` - главный экран (Public Display)
    - `/admin` - интерфейс администратора
    - `/poll/:id` - интерфейс пользователя для участия в опросе

### 4. Redux:

- **Создание хранилища**: Настройте Redux хранилище с использованием `@reduxjs/toolkit`.
- **Состояние приложения**: Определите состояние для хранения данных опросов, текущих вопросов, ответов пользователей и
  статуса подключения WebSocket.

### 5. WebSocket:

- **Socket.IO**: Интегрируйте Socket.IO для общения с бэкендом в реальном времени. Установите соединение и создайте
  обработчики событий для получения вопросов и отправки ответов.

### 6. Axios:

- **HTTP-клиент**: Используйте Axios для выполнения запросов к REST API сервера для операций CRUD опросов и вопросов.

### 7. Компоненты и контейнеры:

- **Главный экран (Public Display)**:
    - `PublicDisplay.jsx` - Контейнер для главного экрана.
    - `QRCodeDisplay.jsx` - Компонент для отображения QR-кода.
    - `QuestionDisplay.jsx` - Компонент для отображения текущего вопроса и визуализации ответов.

- **Интерфейс администратора**:
    - `AdminDashboard.jsx` - Контейнер для интерфейса администратора.
    - `PollCreationForm.jsx` - Форма для создания нового опроса.
    - `QuestionForm.jsx` - Форма для добавления вопросов к опросу.
    - `PollList.jsx` - Компонент для отображения списка опросов.

- **Интерфейс пользователя (User Interface)**:
    - `UserPollPage.jsx` - Контейнер для страницы опроса пользователя.
    - `QuestionForm.jsx` - Компонент формы для ответа на вопросы.

### 8. Тестирование:

- **Jest**: Напишите unit и snapshot тесты для компонентов. Включите тесты Redux хранилища и асинхронных операций.

### 9. Сборка и развертывание:

- **Yarn**: Используйте Yarn для сборки проекта.
- **Vite**: Настройте Vite для оптимизации и минификации сборки для продакшена.

### 10. Формы:

- **React forms**: Используйте библиотеку для управления состоянием форм и валидации данных.

### 11. Инструкции разработчикам:

- **Код-ревью**: Все изменения кода должны проходить через процесс код-ревью.
- **Соблюдение стандартов**: Следуйте установленным стандартам кодирования и соглашениям о названиях.
- **Документирование**: Пишите JSDoc комментарии для всех функций и компонентов.
- **Отладка и профилирование**: Используйте инструменты разработчика браузера для отладки и профилирования приложения.

Это техническое задание создает основу для фронтенд-разработки. Для каждого пункта разработчикам потребуется уточнять
детали, создавать компоненты и писать логику взаимодействия с бэкендом.

# 2. Первые шаги

Для создания фронтенд-части приложения для опросов, разработчикам нужно будет выполнить следующие шаги:

### 1. Инициализация проекта:

Используя терминал, выполните команды для создания нового проекта React с помощью Vite:

```sh
yarn create vite my-poll-app --template react
cd my-poll-app
yarn
```

### 2. Установка зависимостей:

Установите необходимые библиотеки и инструменты для работы с React, Redux, React Router, Socket.IO, Axios, формами и
тестированием:

```sh
yarn add redux react-redux @reduxjs/toolkit react-router-dom socket.io-client axios react-hook-form jest styled-components
yarn add --dev vite-plugin-svgr
```

### 3. Настройка роутинга:

В каталоге `src/`, создайте файл `App.jsx` и настройте основные маршруты приложения с помощью `react-router-dom`:

```jsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import PublicDisplay from './containers/PublicDisplay';
import AdminDashboard from './containers/AdminDashboard';
import UserPollPage from './containers/UserPollPage';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/" element={<PublicDisplay />} />
        <Route path="/admin" element={<AdminDashboard />} />
        <Route path="/poll/:id" element={<UserPollPage />} />
      </Routes>
    </Router>
  );
}

export default App;
```

### 4. Настройка Redux Store:

В каталоге `src/store/`, создайте файл `store.js` и настройте хранилище с использованием `@reduxjs/toolkit`:

```js
import { configureStore } from '@reduxjs/toolkit';

export const store = configureStore({
  reducer: {
    // Добавьте ваши reducers здесь
  },
});
```

### 5. Настройка главного экрана (Public Display):

Создайте компонент `PublicDisplay.jsx` для отображения QR-кода и текущего вопроса:

```jsx
import React from 'react';

function PublicDisplay() {
  // Логика для отображения QR-кода и вопросов

  return (
    <div>
      {/* Компоненты для QR-кода и вопросов */}
    </div>
  );
}

export default PublicDisplay;
```

### 6. Создание интерфейса администратора:

Создайте компонент `AdminDashboard.jsx`, который позволит администратору создавать и управлять опросами:

```jsx
import React from 'react';

function AdminDashboard() {
  // Логика для управления опросами

  return (
    <div>
      {/* Формы и компоненты для управления опросами */}
    </div>
  );
}

export default AdminDashboard;
```

### 7. Создание интерфейса пользователя:

Создайте компонент `UserPollPage.jsx` для участия в опросе:

```jsx
import React from 'react';
import { useParams } from 'react-router-dom';

function UserPollPage() {
  const { id } = useParams(); // ID опроса из URL
  // Логика для отображения и отправки ответов на вопросы

  return (
    <div>
      {/* Компоненты для отображения вопросов и отправки ответов */}
    </div>
  );
}

export default UserPollPage;
```

### 8. Настройка WebSocket соединения:

Создайте утилиту для установки WebSocket соединения и обработки событий:

```js
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

socket.on('connect', () => {
  console.log('WebSocket connection established');
});

// Добавьте обработчики для различных событий WebSocket
```

### 9. Настройка стилей:

Создайте файлы стилей с использованием CSS модулей или styled-components и определите глобальные переменные:

```css
/* styles/variables.css */
:root {
  --primary-color: #0055a5;
  --secondary-color: #f0f0f0;
  /* Остальные переменные */
}
```

### 10. Тестирование:

Настройте Jest для тестирования ваших компонентов и логики Redux:

```sh
yarn add --dev jest @testing-library/react @testing-library/jest-dom
```

Создайте тесты в каталоге `tests/` для каждого компонента и redux слайса.

Эти шаги создадут каркас вашего фронтенд-приложения. Дальнейшая разработка будет включать детализацию каждого
компонента, добавление стейт-менеджмента, настройку взаимодействия с API и веб-сокетами, и создание интерактивных
элементов интерфейса.

# 3. Вторые шаги

После того, как базовая структура вашего фронтенд-приложения настроена, следующими шагами будут:

### 11. Детализация компонентов:

Разработайте и реализуйте детали каждого компонента, включая:

- **Компоненты для отображения QR-кода**: Интеграция с библиотекой для генерации QR-кодов на основе полученного URL.
- **Компоненты форм**: Создание форм для административного интерфейса и пользователя, используя `react-hook-form` для
  управления состоянием формы и валидации.
- **Компоненты визуализации данных**: Если нужно отобразить данные в виде графиков или диаграмм, рассмотрите
  использование библиотеки, например `recharts` или `chart.js`.

### 12. Соединение с бэкендом:

Интегрируйте фронтенд с бэкендом:

- **HTTP-запросы**: Используйте Axios для отправки и получения данных от бэкенд-сервера.
- **WebSocket**: Установите веб-сокет соединение для реального времени обновления главного экрана и интерфейса
  пользователя.

### 13. Стейт менеджмент:

Настройте Redux store:

- **Создайте слайсы**: Используйте `createSlice` из `@reduxjs/toolkit` для опросов, вопросов и ответов.
- **Асинхронные экшены**: Используйте `createAsyncThunk` для асинхронных операций, таких как получение данных опроса или
  отправка ответов.

### 14. Аутентификация и авторизация:

Если в вашем приложении предусмотрена аутентификация и авторизация администратора:

- **Логин**: Создайте компонент и логику для входа в систему администратора.
- **Защита маршрутов**: Используйте `react-router-dom` для защиты приватных маршрутов.

### 15. Обработка и отображение данных:

Реализуйте логику для:

- **Отображения вопросов**: Как только вопрос получен через веб-сокет, отобразите его на главном экране и
  пользовательском интерфейсе.
- **Отправки ответов**: Позвольте пользователям отправлять ответы через формы, и отправьте эти данные обратно на сервер.

### 16. Рефакторинг и оптимизация:

- **Проверьте код**: Убедитесь, что код чистый, хорошо структурирован и соответствует лучшим практикам.
- **Производительность**: Оптимизируйте компоненты для лучшей производительности, например,
  используйте `React.memo`, `useCallback`, `useMemo`.

### 17. Тестирование:

- **Пишите тесты**: Создавайте тесты для компонентов, redux экшенов и редьюсеров, а также для функций утилит.
- **Покрытие кода**: Стремитесь к высокому проценту покрытия кода тестами.

### 18. Документация и комментарии:

- **Документируйте компоненты**: Опишите пропсы, состояние и основные функции компонентов.
- **Комментарии**: Добавьте комментарии к сложным участкам кода.

### 19. Подготовка к деплою:

- **Настройка сборки**: Убедитесь, что ваша сборка оптимизирована для продакшена.
- **Окружение**: Настройте переменные окружения для различения разработки и продакшена.

### 20. Развертывание:

- **Выберите платформу**: Разверните приложение на подходящей платформе хостинга, такой как Netlify, Vercel, AWS,
  Firebase и т.д.

После завершения этих шагов, ваше приложение должно быть готово к бета-тестированию и последующему запуску в продакшен.

# 4. Какие должны быть формы

Для вашего приложения опросов на React, HTML формы будут нужны в основном для интерфейса администратора и интерфейса
пользователя. Вот детали:

### 1. Интерфейс администратора:

#### a) **Форма создания опроса**:

- **Местоположение**: В компоненте `AdminDashboard`.
- **Цель**: Позволить администратору создавать новый опрос, указывая название и другие параметры.
- **Поля**:
    - Название опроса.
    - Описание (опционально).
    - Настройки опроса (например, анонимный/публичный).

#### b) **Форма добавления вопросов**:

- **Местоположение**: В компоненте `PollCreationForm` или `QuestionForm` в `AdminDashboard`.
- **Цель**: Дать возможность администратору добавлять вопросы к опросу.
- **Поля**:
    - Текст вопроса.
    - Тип вопроса (например, открытый вопрос, одиночный выбор, множественный выбор).
    - Варианты ответов (для вопросов с выбором).

### 2. Интерфейс пользователя:

#### a) **Форма ответа на вопрос**:

- **Местоположение**: В компоненте `UserPollPage`.
- **Цель**: Позволить пользователям отвечать на вопросы опроса.
- **Поля**:
    - Выбор ответа (может варьироваться в зависимости от типа вопроса: радиокнопки для одиночного выбора, чекбоксы для
      множественного выбора, текстовое поле для открытых вопросов).

### Общие рекомендации по созданию форм:

- **Валидация**: Обязательно реализуйте валидацию входных данных для каждой формы. Это может быть проверка на пустоту
  для обязательных полей, проверка формата для электронной почты (если требуется), ограничение количества символов для
  текстовых полей и т.д.
- **Управление состоянием формы**: Используйте `react-hook-form` для управления состоянием форм, включая сбор данных,
  обработку отправки и валидацию.
- **Отправка формы**: Настройте обработку отправки формы так, чтобы данные отправлялись на сервер через Axios.
  Убедитесь, что после отправки формы отображается соответствующее уведомление или происходит переход на другую
  страницу (например, обратно к списку опросов после создания нового опроса).

Создание этих форм является ключевым аспектом взаимодействия пользователей с вашим приложением и должно быть выполнено с
вниманием к деталям, удобству использования и надежности.

# 5. Помощь в написании форм

Создать полностью функциональные компоненты форм и стили в текстовом формате непосредственно здесь невозможно, но я могу
предоставить подробные примеры кода и объяснения, которые вы можете использовать как основу для разработки.

### Общие стили для форм:

Создайте CSS модуль `Form.module.css` для общих стилей форм, который можно переиспользовать в различных компонентах:

```css
/* src/styles/Form.module.css */
.formContainer {
  display: flex;
  flex-direction: column;
  margin: 20px;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.formField {
  margin-bottom: 15px;
}

.label {
  margin-bottom: 5px;
  font-weight: bold;
}

.input,
.select,
.textarea {
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.submitButton {
  padding: 10px 20px;
  background-color: #0055a5;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.submitButton:hover {
  background-color: #003d7a;
}
```

### Форма создания опроса:

Файл `PollCreationForm.jsx`:

```jsx
import React from 'react';
import styles from '../styles/Form.module.css';

function PollCreationForm() {
  const handleSubmit = (event) => {
    event.preventDefault();
    // Обработка отправки формы
  };

  return (
    <form onSubmit={handleSubmit} className={styles.formContainer}>
      <div className={styles.formField}>
        <label className={styles.label}>Название опроса</label>
        <input type="text" className={styles.input} required />
      </div>
      <div className={styles.formField}>
        <label className={styles.label}>Описание</label>
        <textarea className={styles.textarea}></textarea>
      </div>
      <button type="submit" className={styles.submitButton}>Создать опрос</button>
    </form>
  );
}

export default PollCreationForm;
```

### Форма добавления вопросов:

Файл `QuestionForm.jsx`:

```jsx
import React from 'react';
import styles from '../styles/Form.module.css';

function QuestionForm() {
  const handleSubmit = (event) => {
    event.preventDefault();
    // Обработка отправки формы
  };

  return (
    <form onSubmit={handleSubmit} className={styles.formContainer}>
      <div className={styles.formField}>
        <label className={styles.label}>Текст вопроса</label>
        <input type="text" className={styles.input} required />
      </div>
      <div className={styles.formField}>
        <label className={styles.label}>Тип вопроса</label>
        <select className={styles.select} required>
          <option value="OPEN">Открытый</option>
          <option value="SINGLE_CHOICE">Одиночный выбор</option>
          <option value="MULTIPLE_CHOICE">Множественный выбор</option>
        </select>
      </div>
      {/* Добавьте поля для вариантов ответов при необходимости */}
      <button type="submit" className={styles.submitButton}>Добавить вопрос</button>
    </form>
  );
}

export default QuestionForm;
```

### Форма ответа на вопрос (для пользователей):

Файл `UserResponseForm.jsx`:

```jsx
import React from 'react';
import styles from '../styles/Form.module.css';

function UserResponseForm({ questionType, options }) {
  const handleSubmit = (event) => {
    event.preventDefault();
    // Обработка отправки формы
  };

  return (
    <form onSubmit={handleSubmit} className={styles.formContainer}>
      {/* Реализуйте различные типы полей в зависимости от questionType и options */}
      <button type="submit" className={styles.submitButton}>Отправить ответ</button>
    </form>
  );
}

export default UserResponseForm;
```

Эти формы служат основой для различных частей вашего приложения. В зависимости от вашей конкретной логики и требований,
вам потребуется дополнить и адаптировать их, добавляя необходимые поля, обработчики событий и логику взаимодействия с
бэкендом.